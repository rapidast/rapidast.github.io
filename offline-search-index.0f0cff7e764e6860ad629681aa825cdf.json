[{"body":"The configuration file is presented as YAML, and contains several main entries:\nconfig : contains configVersion which tells RapiDAST how to consume the config file application : contains data relative to the application being scanned : name, etc. general : contains data that will be used by all the scanners, such as proxy configuration, etc. Each scanner can override an entry from general by creating an entry with the same name scanners : list of scanners, and their configuration Enviornment variables can be used for configuration, e.g. for secrets.\nTemplates See templates in the config directory for rapidast configuration examples.\nconfig-template-zap-tiny.yaml : describes a bare minimum configuration, without authentication options. config-template-zap-simple.yaml : describes a generic/minimal use of the ZAP scanner (i.e.: the minimum set of option to get a ZAP scan from RapiDAST) config-template-zap-mac.yaml : describes a minimal use of the ZAP scanner on a Apple Mac environment config-template-zap-long.yaml : describes a more extensive use of ZAP (all configuration options are presented) config-template-multi-scan.yaml : describes how to combine multiple scanners in a single configuration config-template-generic-scan.yaml : describes the use of the generic scanner config-template-garak-fast.yaml : describes the use of the Garak LLM AI scanner for a fast scan config-template-garak-baseline.yaml : describes the use of the Garak LLM AI scanner for a baseline scan config-template-garak-tool.yaml : describes the use of the Garak LLM AI scanner for a full scan See here for examples on how to run RapiDAST in various CI/CD pipelines.\nBasic example Example bare minimum config file, without any Authentication options, and passive scanning only:\nconfig: configVersion: 5 application: shortName: \"example-1.0\" url: \"https://example.com\" # root URL of the application scanners: zap: apiScan: apis: apiUrl: \"https://example.com/api/v1/swagger.json\" # URL to application openAPI spec ","categories":"","description":"","excerpt":"The configuration file is presented as YAML, and contains several main …","ref":"/docs/02-how-tos/configuration-overview/","tags":"","title":"Configuration Overview"},{"body":"You may not want to directly have configuration values inside the configuration. Typically: either the entry is a secret (such as a password), but the configuration needs to be public, or the entry needs to be dynamically generated (e.g.: a cookie, a uniquely generated URL, etc.) at the time of running RapiDAST, and it’s an inconvenient to always having to modify the configuration file for each run.\nTo avoid this, RapiDAST proposes 2 ways to provide a value for a given configuration entry. For example, to provide a value for the entry general.authentication.parameters.rtoken, you can either (in order of priority):\nCreate an entry in the configuration file (this is the usual method) Create an entry in the configuration file pointing to the environment variable that actually contains the data, by appending _from_var to the entry name: general.authentication.parameters.rtoken_from_var=RTOKEN (in this example, the token value is provided by the $RTOKEN environment variable)\n","categories":"","description":"","excerpt":"You may not want to directly have configuration values inside the …","ref":"/docs/02-how-tos/configuration-using-envvar/","tags":"","title":"Configuration using environment variables"},{"body":"Quickstart Quickly setup RapiDAST to scan a target application. See Workflow for more information.\nCreate a minimal config file for the target application, see Configuration section for details Run RapiDAST with the config file, either in a container or from source code OS Support Linux and MacOS are both supported, however running RapiDAST in a container is currently only supported on Linux. See MacOS Configuration section for more details.\n","categories":"","description":"","excerpt":"Quickstart Quickly setup RapiDAST to scan a target application. See …","ref":"/docs/01-getting-started/","tags":"","title":"Getting Started"},{"body":"ZAP (Zed Attack Proxy) is an open-source DAST tool. It can be used for scanning web applications and API.\nSee https://www.zaproxy.org/ for more information.\nMethodology ZAP needs to be pointed to a list of endpoints to the tested application. Those can be:\nA regular HTML page A REST endpoint A GraphQL interface The GraphQL interface can be provided to RapiDAST via the graphql configuration entry. It requires the URL of the GraphQL interface and the GraphQL schema(if available), in order to be scanned. Additional options are available. See the config-template-zap-long.yaml configuration template file for a list of options.\nThe other endpoints can be provided via several methods, discussed in the chapters below.\nan OpenAPI schema This is the prefered method, to be used whenever possible. RapiDAST accepts OpenAPI v2(formerly known as Swagger) and v3 schemas. These schemas will describe a list of endpoints, and for each of them, a list of parameters accepted by the application.\nBuild the endpoint list using a spider/crawler In this method, RapiDAST is given a Web entrypoint. The crawler will download that page, extract a list of URLs and recursively crawl all of them. The entire list of URLs found is then provided to the scanner.\nThere are two crawlers available:\nBasic spider: the list of URLs will be searched in the HTML tags (e.g.: \u003ca\u003e, \u003cimg\u003e, etc.) Ajax spider: this crawler will run a real browser (by default: firefox headless), allowing the dynamic execution of Javascripts from each page found. This method will find URLs generated dynamically. See the spider and spiderAjax configuration entries in the config-template-zap-long.yaml configuration template file for a list of options available.\nA list of endpoints A file containing a list of URLs corresponding to endpoints and their parameters.\nExample of file:\nhttps://example.com/api/v3/groupA/functionA?parameter1=abc\u0026parameter2=123 https://example.com/api/v3/groupB/functionB?parameter1=def\u0026parameter2=456 Only GET requests will be scanned.\nZAP scanner specific options Below are some configuration options that are worth noting, when running a RapiDAST scan with the ZAP scanner.\n(*.container.type: podman only) Inject the ZAP container in an existing Pod: It is possible to gather both RapiDAST and the tested application into the same podman Pod and run a scan against the application. This might help CI/CD automation \u0026 clean-up. In order to do that, the user must create the Pod prior to running RapiDAST, and indicate its name in the RapiDAST configuration: scanners.zap.container.parameters.podName. However, it is currently necessary to map the host user to UID 1000 / GID 1000 manually during the creation of the Pod using the --userns=keep-id:uid=1000,gid=1000 option Example: podman pod create --userns=keep-id:uid=1000,gid=1000 myApp_Pod\n(when running scans on the desktop with the *.container.type: none configuration only) Enable ZAP’s Graphical UI: This is useful for debugging. Set scanners.zap.miscOptions.enableUI: True (default: False). Then, the ZAP desktop will run with GUI on your host and show the progress of scanning.\nEnable add-on updates: Set scanners.zap.miscOptions.updateAddons: True (default: False). ZAP will first update its addons and then run the scan.\nInstall additional addons: Set scanners.zap.miscOptions.additionalAddons: \"comma,separated,list,of,addons\" (default: []). Prior to running a scan, ZAP will install a given list of addons. The list can be provided either as a YAML list, or a string of the addons, separated by a comma.\nForce maximum heap size for the JVM: Set scanners.zap.miscOptions.memMaxHeap (default: ¼ of the RAM), similarly to Java’s -Xmx option.\nExample:\nscanners: zap: container: parameters: podName: \"myApp_Pod\" miscOptions: enableUI: True updateAddons: False memMaxHeap: \"6144m\" To use ZAP’s ‘-config’ option: Set scanners.zap.miscOptions.overrideConfigs with the same value as you would run with ZAP’s ‘-config’ option. It allows RapiDAST to run additional ‘-config’ options when it invokes the ZAP cli command. This can be useful to set a value for Path parameters of the OpenAPI specification. The following example will allow RapiDAST to send the ‘default’ value to the {namespace} parameter in your OpenAPI file.\nExample:\nscanners: zap: overrideConfigs: - formhandler.fields.field(0).fieldId=namespace - formhandler.fields.field(0).value=default ","categories":"","description":"ZAP - web scanner","excerpt":"ZAP - web scanner","ref":"/docs/03-scanners/zap/","tags":"","title":"ZAP"},{"body":"Authentication is configured in the general entry, as it can be applied to multiple scanning options. Currently, Authentication is applied to [ZAP] scanning only. In the long term it may be applied to other scanning configurations.\nSupported options: No authentication: The scanners will communicate anonymously with the application\nOAuth2 using a Refresh Token: This method describes required parameters needed to retrieve an access token, using a refresh token as a secret.\nauthentication type : oauth2_rtoken parameters : token_endpoint: the URL to which send the refresh token client_id : the client ID rtoken_from_var: for practical reasons, the refresh token is provided using environment variables. This entry describes the name of the variable containing the secret refresh token preauth: Pre-generate a token and force ZAP to use it throughout the session (the session token will not be refreshed after it’s expired). Default: False. This is only useful for scans sufficiently short that it will be finished before the token expires HTTP Basic: This method describes the HTTP Basic Authorization Header. The username and password must be provided in plaintext and will be encoded by the scanners\nauthentication type: http_basic parameters: username password HTTP Header: This method describes the HTTP generic header. The name and value must be provided in plaintext.\nauthentication type: http_header parameters: name: the header name added to every request. By default is Authorization value or value_from_var (the environment variable with the secret) Cookie Authentication This method describes authentication via Cookie header. The cookie name and value must be provided in plaintext.\nauthentication type: cookie parameters: name value Browser authentication This method uses firefox in the background to load a login page and fill in username/password, and will retrieve and set the session cookies accordingly.\nauthentication type: browser parameters: username password loginPageUrl: the URL to the login page (either the full URL, or relative to the application.url value) loginPageWait: The number of seconds to wait after submitting the login form before the browser is closed. (default: 2) verifyUrl: a URL that “proves” the user is authenticated (either the full URL, or relative to the application.url value). This URL must return a success if the user is correctly authenticated, and an error otherwise. loggedInRegex: Regex pattern used to identify Logged in messages (default: \\\\Q 200 OK\\\\) loggedOutRegex: Regex pattern used to identify Logged Out messages (default: \\\\Q 403 Forbidden\\\\) ","categories":"","description":"","excerpt":"Authentication is configured in the general entry, as it can be …","ref":"/docs/02-how-tos/authentication/","tags":"","title":"Authentication"},{"body":"Garak is an LLM AI scanner developed by NVIDIA. See https://github.com/NVIDIA/garak for more information.\nThe following is an example to launch a scan:\nscanners: garak: parameters: plugins: model_type: huggingface model_name: gpt2 ","categories":"","description":"Garak - LLM AI scanner","excerpt":"Garak - LLM AI scanner","ref":"/docs/03-scanners/garak/","tags":"","title":"Garak"},{"body":"","categories":"","description":"How to configure for various scans","excerpt":"How to configure for various scans","ref":"/docs/02-how-tos/","tags":"","title":"How-tos"},{"body":"Run the pre-built rapidast container image, which includes scanners like [ZAP]. Not compatible with config files using general.container.type set to podman.\nPrerequisites:\ndocker / podman (\u003e= v3.0.1) Run:\n$ podman run -v ./config.yaml:/opt/rapidast/config/config.yaml:Z quay.io/redhatproductsecurity/rapidast:latest Note:\nSample config is very minimal and has no Authentication enabled The :Z option is only necessary on RHEL/CentOS/Fedora systems with SELinux enabled To retrieve scan results, add a volume mount like -v ./results/:/opt/rapidast/results/:Z. The permissions of the ./results/ directory may need to be modified first with a command like chmod o+w ./results/ to be writeable by the rapidast user in the container. RapiDAST images are currently built on the linux/amd64 architecture only. To run a scan on MacOS(arm64), use --platform=linux/amd64. ","categories":"","description":"Run RapiDAST in docker container","excerpt":"Run RapiDAST in docker container","ref":"/docs/01-getting-started/run-in-container/","tags":"","title":"Run in container"},{"body":"The following scanners are currently being leveraged. This list will be updated as support for new scanners becomes available.\n","categories":"","description":"Basic information on scanners that are leveraged by RapiDAST","excerpt":"Basic information on scanners that are leveraged by RapiDAST","ref":"/docs/03-scanners/","tags":"","title":"Leveraged scanners"},{"body":"Nessus is a vulnerability scanner developed by Tenable, Inc. It helps organizations identify and address security vulnerabilities across various systems, devices, and applications.\nThe following is an example to launch a scan:\nscanners: nessus: server: url: https://nessus-example.com/ # URL of Nessus instance username: foo # OR username_from_var: NESSUS_USER password: bar # OR password_from_var: NESSUS_PASSWORD scan: name: test-scan # name of new scan to create folder: test-folder # name of folder in to contain scan policy: \"py-test\" # policy used for scan # timeout: 600 # timeout in seconds to complete scan targets: - 127.0.0.1 ","categories":"","description":"Nessus for vulnerability scanning across various targets (requiring a user's own license)","excerpt":"Nessus for vulnerability scanning across various targets (requiring a …","ref":"/docs/03-scanners/nessus/","tags":"","title":"Nessus"},{"body":"Install dependencies and run RapiDAST directly on a host machine. Unless using the config setting of general.container.type: podman, scanners like [ZAP] are expected to be installed on the host system.\nPrerequisites:\npython \u003e= 3.6.8 (3.7 for MacOS/Darwin) podman \u003e= 3.0.1 required when you want to run scanners from their container images, rather than installing them to your host. See requirements.txt for a list of required python libraries Setup:\nClone the repository.\n$ git clone https://github.com/RedHatProductSecurity/rapidast.git $ cd rapidast Create a virtual environment.\n$ python3 -m venv venv $ source venv/bin/activate Install the project requirements.\n(venv) $ pip install -U pip (venv) $ pip install -r requirements.txt Run:\nRun RapiDAST script:\n$ ./rapidast.py --config \u003cpath/to/config.yml\u003e There are more options.\nusage: rapidast.py [-h] [--log-level {debug,info,warning,error,critical}] [--config CONFIG_FILE] [--no-cleanup] Runs various DAST scanners against a defined target, as configured by a configuration file. options: -h, --help show this help message and exit --log-level {debug,info,warning,error,critical} Level of verbosity --config CONFIG_FILE Path to YAML config file --no-cleanup Scanners to not cleanup their environment. (might be useful for debugging purposes). Note:\nExample minimum config expects scanners like [ZAP] to be available on the host, and will fail if not found. See Execution Environments section for more info Results will be written to the ./results/ directory ","categories":"","description":"Run RapiDAST from source code","excerpt":"Run RapiDAST from source code","ref":"/docs/01-getting-started/run-from-source/","tags":"","title":"Run from source"},{"body":"More examples to show how RapiDAST can be run in various CI/CD pipelines are found at https://github.com/RedHatProductSecurity/rapidast/tree/development/examples\n","categories":"","description":"","excerpt":"More examples to show how RapiDAST can be run in various CI/CD …","ref":"/docs/04-ci-cd-examples/","tags":"","title":"CI/CD Examples"},{"body":"In addition to the scanners mentioned above, RapiDAST can run any other scanning tools. It is possible to request RapiDAST to run a command and process stdout results, using the generic plugin. One use case is to run your own tools or scripts and export the results to Google Cloud Storage.\nThe following is an example to run a command or a tool in the host where a RapiDAST scan runs:\nscanners: generic: results: \"*stdout\" # this config is used when container.type is not 'podman' toolDir: scanners/generic/tools inline: \"echo 'any scan'\" (an experimental feature) The following example is to scan a Kubernetes Operator’s controller code for a command injection attack:\nscanners: generic: results: \"*stdout\" # this config is used when container.type is not 'podman' # toolDir: scanners/generic/tools inline: \"python3 oobtkube.py -d 300 -p \u003cport\u003e -i \u003cipaddr\u003e -f \u003ccr_example\u003e.yaml\" The following is another example to run a Trivy scan using the container image:\nscanners: generic: results: \"*stdout\" container: type: \"podman\" parameters: image: \"docker.io/aquasec/trivy\" command: \"image docker.io/aquasec/trivy\" The results entry works as follow:\nif it is missing or *stdout, the output of the command will be chosen and stored as stdout-report.txt in the result directory if it is a directory, it will be recursively copied into the result directory if it is a file, it will be copied into the result directory Notes:\ncommand can be either a list of string, or a single string which will be split using shlex.split() - when using *.container.type: podman, the results (if different from stdout) must be present on the host after podman has run, which likely means you will need to use the container.parameters.volumes entry to share the results between the container and the host. See config/config-template-generic-scan.yaml for additional options. ","categories":"","description":"Generic plugin for advanced users","excerpt":"Generic plugin for advanced users","ref":"/docs/03-scanners/advanced-generic/","tags":"","title":"Generic plugin"},{"body":"This tutorial shows you how to\nCreate a configuration file for testing the web application. Run RapiDAST and get the results. First run with passive scanning only, which can save time at the initial scanning phase. There are various situations that can cause an issue, not only from scanning set up but also from your application or test environment. Active scanning takes a long time in general. Once passive Scanning has run successfully, run another scan with active scanning enabled in the configuration file. Web (OpenAPI based scanning) Create a YAML config file(e.g. config.yaml) like the following:\nconfig: configVersion: 6 application: shortName: \"example-1.0\" url: \"https://example.com\" # root URL of the application scanners: zap: apiScan: apis: apiUrl: \"https://example.com/api/v1/swagger.json\" # URL to application openAPI spec Run a scan:\n$ podman run -v ./config.yaml:/opt/rapidast/config/config.yaml:Z quay.io/redhatproductsecurity/rapidast:latest See here for more information on running a scan\n","categories":"","description":"Getting started with a web scan","excerpt":"Getting started with a web scan","ref":"/docs/01-getting-started/getting-started-with-web-scan/","tags":"","title":"Getting started with a web scan"},{"body":"This simply stores the data as a compressed tarball in a Google Cloud Storage bucket.\nconfig: # Defect dojo configuration googleCloudStorage: keyFile: \"/path/to/GCS/key\" # optional: path to the GCS key file (alternatively: use GOOGLE_APPLICATION_CREDENTIALS) bucketName: \"\u003cname-of-GCS-bucket-to-export-to\u003e\" # Mandatory directory: \"\u003coverride-of-default-directory\u003e\" # Optional directory where the credentials have write access, defaults to `RapiDAST-\u003cproduct\u003e` Once this is set, scan results will be exported to the bucket automatically. The tarball file will include:\nmetadata.json - the file that contains scan_type, uuid and import_data(could be changed later. Currently this comes from the previous DefectDojo integration feature) scans - the directory that contains scan results ","categories":"","description":"","excerpt":"This simply stores the data as a compressed tarball in a Google Cloud …","ref":"/docs/02-how-tos/export-to-gcs/","tags":"","title":"Exporting to Google Cloud Storage"},{"body":"This tutorial shows you how to\nCreate a configuration file for testing a LLM AI model. Run RapiDAST and get the results. LLM Create a YAML config file(e.g. config.yaml) like the following:\nconfig: configVersion: 6 application: shortName: \"garak-test-1.0\" scanners: garak: model_type: huggingface # required, e.g. hugginngface, openai, rest model_name: gpt2 Run a scan:\n$ podman run -v ./config.yaml:/opt/rapidast/config/config.yaml:Z quay.io/redhatproductsecurity/rapidast:latest See here for more information on running a scan\n","categories":"","description":"Getting started with a LLM AI scan","excerpt":"Getting started with a LLM AI scan","ref":"/docs/01-getting-started/getting-started-with-llm-scan/","tags":"","title":"Getting started with a LLM AI scan"},{"body":"Hitting docker.io rate limits If you are unable to pull/update an image from docker.io due to rate-limit errors, authenticate to your Docker Hub account.\n“Error getting access token” using OAuth2 Possible pitfalls :\nMake sure that the parameters are correct (client_id, token_endpoint, rtoken_var_name) and that the refresh token is provided (via environment variable), and is valid Make sure you do not have an environment variable in your current environment that overrides what is set in the envFile Issues with the ZAP scanner The best way to start is to look at the ZAP logs, which are stored in ~/.ZAP/zap.log (within the container where ZAP was running)\nExample with podman, considering that the container was not wiped (either --no-cleanup, or the container failed):\n[rapidast-ng]$ podman container list --all 969d721cc5a8 docker.io/owasp/zap2docker-stable:latest /zap/zap.sh -conf... 2 days ago Exited (1) 2 days ago (unhealthy) rapidast_zap_vapi_JxgLjx [rapidast-ng]$ podman unshare bash-5.2# podman mount rapidast_zap_vapi_JxgLjx /home/cedric/.local/share/containers/storage/overlay/a5450de782fb7264ff4446d96632e6512e3ff2275fd05329af7ea04106394b42/merged bash-5.2# cd /home/cedric/.local/share/containers/storage/overlay/a5450de782fb7264ff4446d96632e6512e3ff2275fd05329af7ea04106394b42/merged bash-5.2# tail home/zap/.ZAP/zap.log org.zaproxy.zap.extension.openapi.converter.swagger.SwaggerException: Failed to parse swagger defn null 2023-02-17 22:42:55,922 [main ] INFO CommandLine - Job openapi added 1 URLs 2023-02-17 22:42:55,922 [main ] INFO CommandLine - Job openapi finished 2023-02-17 22:42:55,923 [main ] INFO CommandLine - Automation plan failures: 2023-02-17 22:42:55,923 [main ] INFO CommandLine - Job openapi target: https://vapi.example.com/api/vapi/v1 error: Failed to parse OpenAPI definition. org.zaproxy.zap.extension.openapi.converter.swagger.SwaggerException: Failed to parse swagger defn null 2023-02-17 22:42:55,924 [main ] INFO Control - Automation Framework setting exit status to due to plan errors 2023-02-17 22:43:01,073 [main ] INFO CommandLineBootstrap - OWASP ZAP 2.12.0 terminated. ZAP’s plugins are missing from the host installation This happens only when using the host’s ZAP (with the *.container.type: none option).\nIf you see a message such as Missing mandatory plugins. Fixing, or ZAP fails with an error containing the string The mandatory add-on was not found:, this is because ZAP deleted the application’s plugin. See https://github.com/zaproxy/zaproxy/issues/7703 for additional information. RapiDAST works around this bug, but with little inconvenients (slower because it has to fix itself and download all the plugins)\nVerify that the host installation directory is missing its plugins. e.g., in a MacOS installation, /Applications/ZAP.app/Contents/Java/plugin/ will be mostly empty. In particular, no callhome*.zap and network*.zap file are present. Reinstall ZAP, but DO NOT RUN IT, as it would delete the plugins. Verify that the directory contains many plugins. chown the installation files to root, so that when running ZAP, the application running as the user does not have sufficient permission to delete its own plugins ZAP crashing with java.lang.OutOfMemoryError: Java heap space ZAP allows the JVM heap to grow up to a quarter of the RAM. The value can be increased using the scanners.zap.miscOptions.memMaxHeap configuration entry\n2023-09-04 08:44:37,782 [main ] INFO CommandLine - Job openapi started 2023-09-04 08:44:46,985 [main ] INFO CommandLineBootstrap - OWASP ZAP 2.13.0 terminated. 2023-09-04 08:44:46,985 [main ] ERROR UncaughtExceptionLogger - Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at java.lang.AbstractStringBuilder.\u003cinit\u003e(AbstractStringBuilder.java:86) ~[?:?] at java.lang.StringBuilder.\u003cinit\u003e(StringBuilder.java:116) ~[?:?] at com.fasterxml.jackson.core.util.TextBuffer.contentsAsString(TextBuffer.java:487) ~[?:?] at com.fasterxml.jackson.core.io.SegmentedStringWriter.getAndClear(SegmentedStringWriter.java:99) ~[?:?] at com.fasterxml.jackson.databind.ObjectWriter.writeValueAsString(ObjectWriter.java:1141) ~[?:?] at io.swagger.v3.core.util.Json.pretty(Json.java:24) ~[?:?] at org.zaproxy.zap.extension.openapi.ExtensionOpenApi.importOpenApiDefinitionV2(ExtensionOpenApi.java:371) ~[?:?] at org.zaproxy.zap.extension.openapi.automation.OpenApiJob.runJob(OpenApiJob.java:123) ~[?:?] at org.zaproxy.addon.automation.ExtensionAutomation.runPlan(ExtensionAutomation.java:366) ~[?:?] at org.zaproxy.addon.automation.ExtensionAutomation.runAutomationFile(ExtensionAutomation.java:507) ~[?:?] at org.zaproxy.addon.automation.ExtensionAutomation.execute(ExtensionAutomation.java:621) ~[?:?] at org.parosproxy.paros.extension.ExtensionLoader.runCommandLine(ExtensionLoader.java:553) ~[zap-2.13.0.jar:2.13.0] at org.parosproxy.paros.control.Control.runCommandLine(Control.java:426) ~[zap-2.13.0.jar:2.13.0] at org.zaproxy.zap.CommandLineBootstrap.start(CommandLineBootstrap.java:91) ~[zap-2.13.0.jar:2.13.0] at org.zaproxy.zap.ZAP.main(ZAP.java:94) ~[zap-2.13.0.jar:2.13.0] ZAP crashed while parsing the OpenAPI due to its size 2024-02-29 19:35:24,526 [main ] INFO CommandLine - Job openapi started 2024-02-29 19:35:25,576 [main ] WARN DeserializationUtils - Error snake-parsing yaml content io.swagger.v3.parser.util.DeserializationUtils$SnakeException: Exception safe-checking yaml content (maxDepth 2000, maxYamlAliasesForCollections 2147483647) at io.swagger.v3.parser.util.DeserializationUtils$CustomSnakeYamlConstructor.getSingleData(DeserializationUtils.java:483) ~[openapi-beta-37.zap:?] at org.yaml.snakeyaml.Yaml.loadFromReader(Yaml.java:493) ~[openapi-beta-37.zap:?] ......... 2024-02-29 19:35:25,639 [main ] ERROR DeserializationUtils - Error parsing content com.fasterxml.jackson.dataformat.yaml.JacksonYAMLParseException: The incoming YAML document exceeds the limit: 3145728 code points. at [Source: (StringReader); line: 49813, column: 50] .......... 2024-02-29 19:35:25,702 [main ] WARN OpenAPIV3Parser - Exception while parsing: com.fasterxml.jackson.dataformat.yaml.JacksonYAMLParseException: The incoming YAML document exceeds the limit: 3145728 code points. at [Source: (StringReader); line: 49813, column: 50] Solutions:\nIf you are using a Swagger v2 definition, try converting it to v3 (OpenAPI) Set a maxYamlCodePoints Java proprety with a big value, which can be passed using environment variables (via the config.environ.envFile config entry): _JAVA_OPTIONS=-DmaxYamlCodePoints=99999999 ZAP’s Ajax Spider failing Insufficient Resources Zap’s Ajax Spider makes use of a lot of resources, in particular:\nShared Memory (/dev/shm) processes If you see evidence of Firefox crashing, either via in the zap.log files stored in session.tar.gz file (see below for examples of such evidence), or logged by an external crash report (such as abrtd for example).\nzap.log hints for Firefox crashing:\n2024-07-04 11:21:32,061 [ZAP-AjaxSpiderAuto] WARN SpiderThread - Failed to start browser firefox-headless com.google.inject.ProvisionException: Unable to provision, see the following errors: 1) [Guice/ErrorInCustomProvider]: SessionNotCreatedException: Could not start a new session. Response code 500. Message: Failed to decode response from marionette Or the following:\n2024-07-04 12:23:28,027 [ZAP-AjaxSpiderAuto] ERROR UncaughtExceptionLogger - Exception in thread \"ZAP-AjaxSpiderAuto\" java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached This issue may also be apparent outside of the spider, in particular, the following error being printed on the RapiDAST output is likely an evidence that the maximum number of concurrent thread is currently reached:\nFailed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 1024k, guardsize: 0k, detached. Solutions:\nSelenium, used to control Firefox, uses shared memory (/dev/shm/). When using the RapiDAST image or the ZAP image, the user needs to make sure that sufficient space is available in /dev/shm/ (in podman, by default, its size is 64MB). A size of 2G is the recommended value by the Selenium community. In podman for example, the option would be --shm-size=2g. Zap and Firefox can create a huge numbers of threads. Some container engines will default to 2048 concurrent pids, which is not sufficient for the Ajax Spider. Whenever possible, RapiDAST will check if that limit was reached, after the scan is finished, and prints a warning if this happened. In podman, increasing the maximum number of concurrent pids is done via the --pids-limit=-1 option to prevent any limits. Podman errors subuid/subgid are not enabled If you see one of those errors:\nError: copying system image from manifest list: writing blob: adding layer with blob \"sha256:82aabceedc2fbf89030cbb4ff98215b70d9ae35c780ade6c784d9b447b1109ed\": processing tar file(potentially insufficient UIDs or GIDs available in user namespace (requested 0:42 for /etc/gshadow): Check /etc/subuid and /etc/subgid if configured locally and run \"podman system migrate\": lchown /etc/gshadow: invalid argument): exit status 1 -or-\nError: parsing id map value \"-1000\": strconv.ParseUint: parsing \"-1000\": invalid syntax Podman, in rootless mode (running as a regular user), needs subuid/subgit to be enabled: rootless mode\nCaveats Currently, RapiDAST does not clean up the temporary data when there is an error. The data may include: a /tmp/rapidast_*/ directory a podman container which name starts with rapidast_ This is to help with debugging the error. Once confirmed, it is necessary to manually remove them.\n","categories":"","description":"","excerpt":"Hitting docker.io rate limits If you are unable to pull/update an …","ref":"/docs/05-troubleshoot/","tags":"","title":"Troubleshooting"},{"body":"Install project requirements for development Install dependencies using the requirements-dev.txt file.\n$ pip install -r requirements-dev.txt Install pre-commit pre-commit is being used to ensure that all code committed to the repository meets a certain level of quality and consistency, e.g. regarding style and formatting issues.\nThe current checks are found in the .pre-commit-config.yaml file.\nOnce pre-commit is installed in the following way, code will be checked automatically when a commit is made.\n$ pre-commit install pytest Add test cases under tests/ when adding a new feature or function if possible. Consult the pytest homepage as necessary.\nMake sure every test case passes whenever any commit is to be made, with the following command:\n$ pytest Structure Its structure is as follow:\nrapidast.py does: Loading the main configuration file For each scanner activated by the config, running it Adding a scanner A scanner should:\nbe placed in a subdirectory of the scanners/ directory inherit from RapidastScanner class implement these functions : __init__(config) : config being the entire configuration setup() : creates whatever needs to be done prior to run run() : runs the scan postprocess() : stores the results in the global result directory, etc. cleanup() : deletes temporary files, shutdown server, etc. Set a className string for the scanner, which helps RapiDAST to know which class should be implemented Example: className = \"Zap\" Authentication factory A small authentication helper has been provided in the form of decorators. Scanners who want to authenticate should use it.\nTo create an authentication decorator, the scanner (e.g.: zap) needs to first create a decorator associated with the default behaviour (e.g.: likely either anonymous or error handling)\nExample for the ZAP scanner (scanners.zap):\nfrom scanners.authentication_factory import generic_authentication_factory @generic_authentication_factory() def authentication_factory(self): \"\"\"Default action, called when no corresponding authenticator were found\"\"\" Once done, simply register each authentication type, based on scanners.*.authentication.type :\n@authentication_factory.register(\"http_basic\") def authentication_set_http_basic_auth(self): \"\"\"Configure HTTP Basic authentication\"\"\" Then calling the authentication_factory() function will automatically redirect the call to the correct authentication function.\nPath helper Because scanners may need to handle path from the “host” view and the “container” view, and translate from one to another, we have created a path_translator module to facilitate this.\nIn practice, this helps to copy files in and out of the container section, or calculate paths inside the container, indepently from the “container” technology. The scanner first needs to setup the mapping correctly, and the rest of the code can work according to the mapping. The mapping usually corresponds to mountpoints, or important directory where the code will need to store/retrieve data.\nExample :\nfrom scanners.path_translators import PathMaps from scanners.path_translators import PathMap path_map = PathMaps(\"workdir\", \"policies\", \"scripts\") path_map.workdir = PathMap(\"/on/host/workdir\", \"/in/container/workdir\") print(f\"workdir in container: {path_map.workdir.container_path}\") myfile = \"/in/container/workdir/results/myresults.txt\" print(f\"myfile on host: {path_map.container_2_host(myfile)}\") NOTES\nImportant note: there is currently no support for submount : if a mapping is set to /my/first/mount, there can not be another map to /my/first/mount/my/other/mount The path are immutable: they must be chosen during creation (in the __init__() function), and must not be modified afterwards. The parent scanner (e.g.: Zap) should define the mount points, and each runtime (e.g.: ZapPodman) should fill each map once For type = None (the scanner will run on the host), then the map must be the same (e.g.: PathMap(\"/path/to/dir\", \"/path/to/dir\")) Podman wrapper A podman scanner can instanciate a PodmanWrapper object. This provides functions to prepare the podman command, such as adding volumes, etc.\nExample:\n# Initialize podman self.podman = PodmanWrapper( app_name=self.config.get(\"application.shortName\"), scan_name=self.ident, image = self.my_conf(\"container.parameters.image\", default=\"docker.io/group/application:latest\") ) cli = self.podman.get_complete_cli(self.generic_cli) self.podman.deploy_to_pod(\"myPod\") self.podman.add_volume_map(\"/tmp/result/:/var/results/:Z\") cli = self.podman.get_complete_cli(self.generic_cli) subprocess.run(self.podman.get_complete_cli([\"touch\", \"/var/results/file\"])) self.podman.delete_yourself(): Integrating the scanner to Defect Dojo If a scanner is supported by Defect Dojo, the scanner can be configured to export its scan results to Defect Dojo automatically. All it needs to do is to create an optional data_for_defect_dojo() method (no parameters). This can be useful when the scanner exports a file that can be imported into a Defect Dojo test. This method must return a tuple of 2 values:\nA dictionary containing a subset of values accepted by Defect Dojo’s import-scan or reimport-scan endpoints (see https://demo.defectdojo.org/api/v2/doc/) A string corresponding to path of the file containing the scan result, in a format parsable by Defect Dojo. The dictionary must not:\ncontain the file entry, as it is done via the tuple’s 2nd value The dictionary must:\nContain enough information to let Defect Dojo import the file (e.g.: provide a test identifier for re-import, or at least a product_name + engagement_name so that Defect Dojo can create a test on its own) Provide the scan scan_type corresponding to the result file (e.g.: ZAP Scan for ZAP), as well as all other mandatory field (verified and active) Note: simply return the (None, None) tuple to abort the operation.\nThe configuration model The “RapidastConfigModel” object is used to load and merge YAML configuration files. This provides several benefits:\nIt is possible to get the values without having to manually walk through the configuration tree, using code such as config.get(\"scanners.zap.apis.apiUrl\", default=\"\"). There is no need to try/except the code, or verify the existence of a key before descending. If a key (or path to the key) does not exist, default will be returned. Similarly config.set(\"scanners.zap.apis.apiUrl\", \"http://example.com/\") will create the path if needed, without raising an exception. To merge a dictionary into a configuration, use config.merge(merge: dict, preserve: bool, root: path): + from config[\u003croot\u003e] onwards, the configuration will copy values from merge, descending on keys of the same name + in case of collision (2 keys with same name, but at most only 1 value is a dictionary), the original configuration will be preserved only if preserve=True was set\nDevelopers are encouraged to use this configuration model, although the configuration can be directly accessed via the underlying config.config dict\nWARNINGS and LIMITATIONS:\nCurrently, the model does not support lists ( e.g.: - or [] in YAML), i.e.: config.get(\"path.to.list[0]\") does not work. Avoid those if possible, otherwise get a reference to the list (i.e.: config.get(\"path.to.list\")) , and manipulate it in python directly. Default value Currently, the default value of a config entry is being set in the code like \u003cconfigModel\u003e.get(\"path.to.entry\", default=\"\u003csane-default\u003e\"). When looking up an entry, the developer has the responsibility to make a “good default” in case the entry does not exist in the configuration.\nNote/Warning: This has the downside of possibly having different default values for the same entry, which may be problematic (also, we need to be careful when we want to change the default).\nAutomatically updating the configuration schema There may be time during which development requires incompatible changes in the configuration schema, such as renaming, deleting or moving of an entry. An “incompatible change” means any change in the code that would prevent a previously working configuration file from working correctly. This must be avoided. For example, adding new entries should not impact previous configuration provided that default values are mimicking previous behavior. Otherwise, this creates an issue while handling users’ current configuration which hasn’t been updated yet.\nRapiDAST works around the issue in the following way. Every time there is an incompatible change:\nIn configmodel/converter.py : a) increase CURR_CONFIG_VERSION by 1 (in the following text, the old number is referred to as $X, and, respectively the updated version number as ${X+1} ) b) write a converter function, decorated with @convert_configmodel.register(${X}) This function must take a configuration schema version ${X}, and must return a copy, updated to ${X+1} Keep a copy of config-template-long.yaml, named config/older-schemas/v${X}.yaml. This is just for safekeeping, so that we don’t need to go through git history to retrieve previous schemas. Make the changes in the config/config-template*.yaml files. Including: a) config.configVersion must be set to ${X+1} b) all the changes are applied (config-template-long.yaml should contain all changes, and config-template.yaml only the user-friendly ones Provide explanation in the corresponding commit Create a new configuration schema in the appropriate file: config/schemas/$(X+1)/rapidast_schema.json RapiDAST, when loading the configuration from file, will update the schema, version by version, by chaining all the converting functions one by one until CURR_CONFIG_VERSION is reached. e.g.: from 2 to 3, then 3 to 4, 4 to 5, etc.\nNote: it is possible for a converter function to warn the user, if necessary. As a last resort, if there is no conversion possible, it is also possible to output an error BUT the error should clearly express a methodology to manually update the configuration to the newest version\nPython Requirements Management This project uses pip-compile from pip-tools to manage dependencies.\nRequirements Make sure you have an environment that closely matches the environment in the container build. This means it should have the same operating system and the same Python $major.$minor version.\npip-tools: Used for managing Python dependencies and generating requirements.txt Installing a new dependency To add a new dependency, follow these steps:\nAdd the dependency to requirements.in\nRecompile requirements.txt to update dependencies, run the following command:\npip-compile requirements.in This will regenerate requirements.txt with the newly added dependency and its pinned versions.\nInstalling a new development only dependency To add a new dependency, follow these steps:\nAdd the dependency to requirements-dev.in\nRecompile requirements-dev.txt to update dependencies, run the following command:\npip-compile requirements-dev.in This will regenerate requirements-dev.txt with the newly added dependency and its pinned versions.\n","categories":"","description":"RapiDAST Developer's guide","excerpt":"RapiDAST Developer's guide","ref":"/docs/06-developer-guide/","tags":"","title":"Developer's guide"},{"body":"RapiDAST supports integration with OWASP DefectDojo which is an open source vulnerability management tool.\nPreamble: creating DefectDojo user RapiDAST needs to be able to authenticate to your DefectDojo instance. However, ideally, it should have the minimum set of permissions, such that it will not be allowed to modify products other than the one(s) it is supposed to.\nIn order to do that:\ncreate a user without any global role add that user as a “writer” for the product(s) it is supposed to scan Then the product, as well as an engagement for that product, must be created in your DefectDojo instance. It would not be advised to give the RapiDAST user an “admin” role and simply set auto_create_context to True, as it would be both insecure and accident prone (a typo in the product name would let RapiDAST create a new product)\nExporting to Defect Dojo RapiDAST will send the results directly to a DefectDojo service. This is a typical configuration:\nconfig: # Defect dojo configuration defectDojo: url: \"https://mydefectdojo.example.com/\" ssl: [True | False | \"/path/to/CA\"] authorization: username: \"rapidast_productname\" password: \"password\" # alternatively, a `token` entry can be set in place of username/password The ssl parameter is provided as the Python Requests module’s verify parameter. It can be either:\nTrue: SSL verification is mandatory, against the default CA bundle False: SSL verification is not mandatory (but prints a warning if it fails) /path/to/CA: a bundle of CAs to verify from Alternatively, the REQUESTS_CA_BUNDLE environment variable can be used to select a CA bundle file. If nothing is provided, the default value will be True\nYou can either authenticate using a username/password combination, or a token (make sure it is not expired). In either case, you can use the _from_var method described in the previous chapter to avoid hardcoding the value in the configuration.\nConfiguration of exported data The data exported follows the Defectdojo methodology of “Product → Engagement → Test” : a test, such as a ZAP scan, belongs to an engagement for a product. Its configuration is made under the scanners.\u003cscanner\u003e.defectDojoExport.parameters configuration entries. As a baseline, parameters from the Defectdojo import-scan and reimport-scan are accepted.\nFor each scan, the logic applied is the following, in order:\nIf a test ID is provided (parameter test), this scan will replace the previous one (a “reimport” in Defectdojo) If an engagement ID is provided (parameter engagement), this scan will be added as a new test in that existing engagement If an engagement and a product are given by name (engagement_name and product_name parameters), this scan will be added for that given engagement for the given product In each defectDojoExport.parameters, some defaults parameters are applied:\nproduct_name, in order (the first non empty value found): application.productName application.shortName (this name should not contain non-printable characters, such as spaces) engagement_name defaults to RapiDAST-\u003cproduct name\u003e-\u003cdate\u003e scan_type : filled by the scanner active: True verified: False As a reminder: values from general are applied to each scanner.\nHere is an example:\nscanners: zap: defectDojoExport: parameters: product_name: \"My Product\" engagement_name: \"RapiDAST\" # or engagement: \u003cengagement_id\u003e #test: \u003ctest_id\u003e See https://documentation.defectdojo.com/integrations/importing/#api for more information.\n","categories":"","description":"","excerpt":"RapiDAST supports integration with OWASP DefectDojo which is an open …","ref":"/docs/02-how-tos/export-to-owasp-defect-dojo/","tags":"","title":"Exporting to OWASP Defect Dojo"},{"body":"It is possible to run a scanner several times with different configurations. This is done by adding a different identifier to each scan, by appending _\u003cid\u003e to the scanner name.\nFor example :\nscanners: zap_unauthenticated: apiScan: apis: apiUrl: \"https://example.com/api/openapi.json\" zap_authenticated: authentication: type: \"http_basic\" parameters: username: \"user\" password: \"mypassw0rd\" apiScan: apis: apiUrl: \"https://example.com/api/openapi.json\" In the example above, the ZAP scanner will first run without authentication, and then rerun again with a basic HTTP authentication. The results will be stored in their respective names (i.e.: zap_unauthenticated and zap_authenticated in the example above).\n","categories":"","description":"","excerpt":"It is possible to run a scanner several times with different …","ref":"/docs/02-how-tos/multiple-scans/","tags":"","title":"Multiple scans at once"},{"body":"When running RapiDAST scans from source on your localhost, specify the path to the scanning tool if it is not included in your system’s PATH.\nFor macOS, the default path to ZAP is typically /Applications/ZAP.app/Contents/Java/zap.sh.\nExample:\nscanners: zap: container: parameters: executable: \"/Applications/ZAP.app/Contents/Java/zap.sh\" ","categories":"","description":"","excerpt":"When running RapiDAST scans from source on your localhost, specify the …","ref":"/docs/02-how-tos/specify-scanner-path/","tags":"","title":"Specifiying scanner path"},{"body":"If you want to build your own RapiDAST image, run the following command.\n$ podman build . -f containerize/Containerfile -t \u003cimage-tag\u003e\nDisclaimer: This tool is not intended to be run as a long-running service. Instead, it is designed to be run for a short period of time while a scan is being invoked and executed in a separate test environment. If this tool is used solely for the scanning purposes, vulnerabilities that may be indicated to exist in the image will not have a chance to be exploited. The user assumes all risks and liability associated with its use.\n","categories":"","description":"","excerpt":"If you want to build your own RapiDAST image, run the following …","ref":"/docs/02-how-tos/build-image/","tags":"","title":"Build a RapiDAST image"},{"body":"RapiDAST scans can be performed by using the Helm chart included in the repository. Consult https://helm.sh/docs/intro/quickstart/ to install Helm.\nThe Helm chart uses the official RapiDAST image: quay.io/redhatproductsecurity/rapidast:latest based on the code in the main branch.\nIf you want to run a scan with the custom RapiDAST image(e.g. using the latest code in the development branch), you’ll need to build your own image and push it to your container registry. And update the image section of your chart/values.yaml file, according to your image name and tag.\nIn addition, values.yaml contains various configuration items including a RapiDAST config template and default scan policy. Either you modify it for your environment or override by using –set-file, –set or -f.\nFor example, using –set-file rapidastConfig, it is possible to update configuration for RapiDAST scans.\n$ helm install rapidast ./helm/chart/ --set-file rapidastConfig=\u003cyour-rapidast-config-with-container-type-none.yaml\u003e NOTE: general.container.type in the config must be none as scanners are already built in the RapiDAST image and Kubernetes/OpenShift orchestrates it instead of podman.\nIt is also possible to override the scan policy in the same way.\n$ helm install rapidast ./helm/chart/ --set-file scanPolicyXML=\u003cyour-custom-scan-policy.xml\u003e\nGetting Results Once the scan has been finished, the result is stored in your PersistentVolume (default: through PersistentVolumeClaim(PVC), which is rapidast-pvc. See the charts/values.yaml.)\nThe easiest way to get results is to use a pod that mounts the same PVC used to store the results, and use kubectl cp POD:/results_dir local_dir to copy an entire directory, or kubectl cp POD:/path/to/file /local/path for a single file.\nFor convenience, a script results.sh is provided. It will create a pod mounting the specified PVC, then use kubectl cp to copy the entire results directory to your specified local directory before deleting the pod.\nTo use the script, first you will need a copy of kubeconfig in your current directory. Then, run results.sh with the following usage:\n$ bash results.sh \u003cPVC\u003e \u003cLOCAL_RESULTS_DIR\u003e For example, run it in the root of the RapiDAST repository like the following:\nrapidast]$ bash helm/results.sh rapidast-pvc /tmp/results/\nRunning on OpenShift When running on OpenShift, make sure that your namespace you are running on has proper privileges for running a pod/container\nYou’ll need to set secContext: ‘{“privileged”: true}’ at https://github.com/RedHatProductSecurity/rapidast/blob/development/helm/chart/values.yaml#L14\n","categories":"","description":"","excerpt":"RapiDAST scans can be performed by using the Helm chart included in …","ref":"/docs/02-how-tos/run-on-kubernetes/","tags":"","title":"Running on Kubernetes or OpenShift"},{"body":"Contribution to the project is more than welcome.\nContribution to the documentation: TBD Contribution to the RapiDAST project: CONTRIBUTING.md ","categories":"","description":"How to contribute to RapiDAST","excerpt":"How to contribute to RapiDAST","ref":"/docs/10-contributing/","tags":"","title":"Contributing"},{"body":"RapiDAST (Rapid DAST) is an open-source security testing tool that automates DAST (Dynamic Application Security Testing) and streamlines the integration of security testing into development workflows. It is designed to help Developers and/or QA engineers rapidly and effectively identify low-hanging security vulnerabilities in your applications, ideally in CI/CD pipelines. RapiDAST is for organizations implementing DevSecOps with a shift-left approach.\n","categories":"","description":"","excerpt":"RapiDAST (Rapid DAST) is an open-source security testing tool that …","ref":"/docs/","tags":"","title":"Documentation"},{"body":" Automated security testing tool focused on DevSecOps and shift-left Documentation GitHub RapiDAST RapiDAST is an open-source security testing tool that automates DAST (Dynamic Application Security Testing) and streamlines the integration of security testing into development workflows\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRed Hat Product Security Red Hat Product Security strives to protect communities from digital security threats. We believe open source principles are the best way to achieve this\n","categories":"","description":"","excerpt":" Automated security testing tool focused on DevSecOps and shift-left …","ref":"/","tags":"","title":"RapiDAST"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"}]